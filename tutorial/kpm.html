

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="Approximating various functions using the kernel polynomial method (KPM)" name="description" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>10. Kernel polynomial method &mdash; pybinding</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />

  
    <link rel="stylesheet" href="../_static/extra.css" type="text/css" />
      <script src="../_static/documentation_options.js?v=e2a723ec"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. Scattering model" href="scattering.html" />
    <link rel="prev" title="9. Eigenvalue solvers" href="solvers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            pybinding
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">About</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks/index.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="import.html">1. Imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="lattice.html">2. Lattice</a></li>
<li class="toctree-l2"><a class="reference internal" href="bands.html">3. Band structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="finite.html">4. Finite size</a></li>
<li class="toctree-l2"><a class="reference internal" href="shape_symmetry.html">5. Shape and symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="fields.html">6. Fields and effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="strain.html">7. Defects and strain</a></li>
<li class="toctree-l2"><a class="reference internal" href="generators.html">8. Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvers.html">9. Eigenvalue solvers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10. Kernel polynomial method</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#about-kpm">10.1. About KPM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#builtin-methods">10.2. Builtin methods</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ldos">10.2.1. LDOS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dos">10.2.2. DOS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#spatial-ldos">10.2.3. Spatial LDOS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#green-s-function">10.2.4. Green’s function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#conductivity">10.2.5. Conductivity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#damping-kernels">10.3. Damping kernels</a></li>
<li class="toctree-l3"><a class="reference internal" href="#low-level-interface">10.4. Low-level interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#further-reading">10.5. Further reading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="scattering.html">11. Scattering model</a></li>
<li class="toctree-l2"><a class="reference internal" href="wavefunction.html">12. Wavefunction calculations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/index.html">Additional Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plotting/index.html">Plotting Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Random Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../materials/index.html">Material Repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experimental/index.html">Experimental</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pybinding</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Tutorial</a></li>
      <li class="breadcrumb-item active"><span class="section-number">10. </span>Kernel polynomial method</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tutorial/kpm.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="kernel-polynomial-method">
<h1><span class="section-number">10. </span>Kernel polynomial method<a class="headerlink" href="#kernel-polynomial-method" title="Link to this heading">¶</a></h1>
<p>The kernel polynomial method (KPM) can be used to quickly compute various physical properties
of very large tight-binding systems. It makes use of Chebyshev polynomial expansion together with
damping kernels. Pybinding includes a fast <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.kpm" title="pybinding.chebyshev.kpm"><code class="xref py py-func docutils literal notranslate"><span class="pre">kpm()</span></code></a> implementation with several easy-to-use
computation methods as well as a low-level interface for computing KPM expansion moments.</p>
<p><a class="reference download internal" download="" href="../_downloads/815e0afe8bc9fd9a8bb077bca501618b/kpm.ipynb"><code class="xref nbexport download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">this</span> <span class="pre">page</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">Jupyter</span> <span class="pre">notebook</span></code></a></p>
<section id="about-kpm">
<h2><span class="section-number">10.1. </span>About KPM<a class="headerlink" href="#about-kpm" title="Link to this heading">¶</a></h2>
<p>For a full review of the kernel polynomial method, see the reference paper
<a class="reference external" href="https://doi.org/10.1103/RevModPhys.78.275">Rev. Mod. Phys. 78, 275 (2006)</a>.
Here, we shall only briefly describe the main characteristics of KPM and some specifics of its
implementation in pybinding.</p>
<p>As we saw on the previous page, exactly solving a tight-binding problem implies the diagonalization
of the Hamiltonian matrix. However, the computational resources required by eigenvalue solvers
scale up rapidly with system size which makes it challenging to solve realistically large systems.
A fundamentally different approach is to set aside the requirement for exact solutions (avoid
diagonalization altogether) and instead use approximative methods to calculate the properties
of interest. This is the main idea behind KPM which approximates functions as a series of
Chebyshev polynomials.</p>
<p>The approximative nature of the method presents an opportunity for additional performance tuning.
Results may be computed very quickly with low accuracy to get an initial estimate for the problem
at hand. Once final results are required, the accuracy can be increased at the cost of longer
computation time. Within pybinding, this KPM calculation quality is frequently expressed as an
energy broadening parameter.</p>
<p>One of the great benefits of this method is that spatially dependent properties such as the local
density of states (LDOS) or Green’s function are calculated separately for each spatial position.
This means that localized properties can be computed extremely quickly. For this application, KPM
can be seen as orthogonal to traditional eigenvalue solvers. Sparse diagonalization produces
results for a very small energy range (eigenvalues) but does so for all positions simultaneously
(eigenvectors). With KPM, it’s possible to separate and compute individual positions but for the
entire energy spectrum at once. In this way, the two approaches complement each other nicely.</p>
</section>
<section id="builtin-methods">
<h2><span class="section-number">10.2. </span>Builtin methods<a class="headerlink" href="#builtin-methods" title="Link to this heading">¶</a></h2>
<p>Before using any of the computation methods, the main <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM" title="pybinding.chebyshev.KPM"><code class="xref py py-class docutils literal notranslate"><span class="pre">KPM</span></code></a> object needs to be created
for a specific model:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="c1"># ... use kpm</span>
</pre></div>
</div>
<section id="ldos">
<h3><span class="section-number">10.2.1. </span>LDOS<a class="headerlink" href="#ldos" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_ldos" title="pybinding.chebyshev.KPM.calc_ldos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_ldos()</span></code></a> method makes it very easy to calculate the local density of states
(LDOS). In the next example we’ll use a large square sheet of pristine graphene:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pybinding.repository</span><span class="w"> </span><span class="kn">import</span> <span class="n">graphene</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span> <span class="n">pb</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="n">ldos</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_ldos</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">ldos</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Graphene density of states" class="plot-directive" src="../_images/kpm-1.png" />
</figure>
<p>The LDOS is calculated for energies between -9 and 9 eV with a Gaussian broadening of 50 meV.
Since this is the <em>local</em> density of states, position is also a required argument. We target the
center of our square system where we expect to see the well-known LDOS shape of pristine graphene.</p>
<p>Thanks to KPM, the calculation of this local property is very fast: about 0.1 seconds for the
example above with a 60 x 60 nm sheet of graphene. The broadening parameter offers the possibility
for performance tuning – calculation time is inversely proportional to broadening width. KPM
performs the computation for the entire spectrum simultaneously, so the selected energy range and
the number of sample points have almost no effect on performance. The broadening width (i.e. the
precision of the results) is the main factor which determines the duration of the calculation.</p>
<p>The result of the calculation is a <a class="reference internal" href="../_api/pybinding.Series.html#pybinding.Series" title="pybinding.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> object which contains the LDOS data, the energy
array for which it was calculated, and the associated data labels. This allows the
<a class="reference internal" href="../_api/pybinding.Series.html#pybinding.Series.plot" title="pybinding.Series.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.plot()</span></code></a> method to automatically plot a nicely labeled line plot, as seen above.
Accessing the raw data represented on the y-axis is possible via the <code class="xref py py-attr docutils literal notranslate"><span class="pre">Series.data</span></code>
attribute, i.e. <code class="samp docutils literal notranslate"><span class="pre">ldos.data</span></code> in this specific case.</p>
<p>Tight-binding systems have lattice sites at discrete positions, which in principle means that we
cannot freely choose just any position for LDOS calculations. However, as a convenience the
<a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_ldos" title="pybinding.chebyshev.KPM.calc_ldos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_ldos()</span></code></a> method will automatically find a valid site closest to the given target
position. We can optionally also choose a specific sublattice:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ldos</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_ldos</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                     <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sublattice</span><span class="o">=</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case we would calculate the LDOS at a site of sublattice B closest to the center of the
system. We can try that on a graphene system with a mass term:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span>
    <span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span>
    <span class="n">graphene</span><span class="o">.</span><span class="n">mass_term</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">pb</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="k">for</span> <span class="n">sub_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">]:</span>
    <span class="n">ldos</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_ldos</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                         <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sublattice</span><span class="o">=</span><span class="n">sub_name</span><span class="p">)</span>
    <span class="n">ldos</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">sub_name</span><span class="p">)</span>
<span class="n">pb</span><span class="o">.</span><span class="n">pltutils</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Graphene density of states (with mass term induced by a substrate)" class="plot-directive" src="../_images/kpm-2.png" />
</figure>
<p>Multiple plots compose nicely here. A large band gap is visible at zero energy due to the inclusion
of <a class="reference internal" href="../materials/graphene.html#pybinding.repository.graphene.modifiers.mass_term" title="pybinding.repository.graphene.modifiers.mass_term"><code class="xref py py-func docutils literal notranslate"><span class="pre">graphene.mass_term()</span></code></a>. It places an onsite potential with
the opposite sign in each sublattice. This is also why the LDOS lines for A and B sublattices are
antisymmetric around zero energy with respect to one another.</p>
</section>
<section id="dos">
<h3><span class="section-number">10.2.2. </span>DOS<a class="headerlink" href="#dos" title="Link to this heading">¶</a></h3>
<p>The following example demonstates the usage of the <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_dos" title="pybinding.chebyshev.KPM.calc_dos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_dos()</span></code></a> method which computes
the total density of states (DOS) in a system:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span> <span class="n">pb</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="n">dos</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_dos</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">2.7</span><span class="p">,</span> <span class="mf">2.7</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.06</span><span class="p">,</span> <span class="n">num_random</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">dos</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Graphene zigzag nanoribbon density of states" class="plot-directive" src="../_images/kpm-3.png" />
</figure>
<p>The example system here is a very long but narrow (400 x 2 nm) rectangle of graphene, i.e. a zigzag
nanoribbon of finite length. The pronounced zero-energy peak is due to zigzag edge states and the
additional higher-energy DOS peaks reflect the quantized band structure of the narrow nanoribbon.</p>
<p>A specific feature of the KPM-based DOS calculation is that it can be approximated very quickly
using stochastic methods. Instead of computing the density of states at each sites individually
and summing up the results, the DOS is calculated for all sites at the same time, but with a random
contribution of each site. By repeating this procedure multiple times with different random staring
states, the full DOS is recovered. This presents an additional knob for performance/quality tuning
via the <code class="samp docutils literal notranslate"><span class="pre">num_random</span></code> parameter.</p>
<p>For this example, we keep <code class="samp docutils literal notranslate"><span class="pre">num_random</span></code> low to keep the calculation time under 1 second. Increasing
this number would smooth out the DOS further. Luckily, the stochastic evaluation converges as a
function of both the system size and number of random samples. Thus, the larger the model system,
the smaller <code class="samp docutils literal notranslate"><span class="pre">num_random</span></code> needs to be for the same result quality.</p>
</section>
<section id="spatial-ldos">
<h3><span class="section-number">10.2.3. </span>Spatial LDOS<a class="headerlink" href="#spatial-ldos" title="Link to this heading">¶</a></h3>
<p>To see the spatial distribution of the density of states, we could call the <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_ldos" title="pybinding.chebyshev.KPM.calc_ldos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_ldos()</span></code></a>
method for several positions and populate a <code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMap</span></code>. However, this would be tedious and
slow, so instead we have <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_spatial_ldos" title="pybinding.chebyshev.KPM.calc_spatial_ldos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_spatial_ldos()</span></code></a> which makes this much simpler. Let’s use
a strained bit of graphene as an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">gaussian_bump_strain</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Out-of-plane deformation (bump)&quot;&quot;&quot;</span>
    <span class="nd">@pb</span><span class="o">.</span><span class="n">site_position_modifier</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">displacement</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># gaussian</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">+</span> <span class="n">dz</span>  <span class="c1"># only the height changes</span>

    <span class="nd">@pb</span><span class="o">.</span><span class="n">hopping_energy_modifier</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">strained_hoppings</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z1</span><span class="o">-</span><span class="n">z2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># strained neighbor distance</span>
        <span class="k">return</span> <span class="n">energy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">3.37</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="n">graphene</span><span class="o">.</span><span class="n">a_cc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># see strain section</span>

    <span class="k">return</span> <span class="n">displacement</span><span class="p">,</span> <span class="n">strained_hoppings</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">()</span><span class="o">.</span><span class="n">with_offset</span><span class="p">([</span><span class="o">-</span><span class="n">graphene</span><span class="o">.</span><span class="n">a</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                 <span class="n">pb</span><span class="o">.</span><span class="n">regular_polygon</span><span class="p">(</span><span class="n">num_sides</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">4.5</span><span class="p">),</span>
                 <span class="n">gaussian_bump_strain</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="mf">1.6</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.6</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.7</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;xy-plane&quot;</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">model</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;xz-plane&quot;</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="s2">&quot;xz&quot;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Modeling out-of-plane strain in graphene (Gaussian bump)" class="plot-directive" src="../_images/kpm-4.png" />
</figure>
<p>The bump produces purely out-of-plane strain so the xy-plane does not show any signs of the
deformation. Switching to the xz-plane reveals the bump.</p>
<p>The <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_spatial_ldos" title="pybinding.chebyshev.KPM.calc_spatial_ldos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_spatial_ldos()</span></code></a> method takes the same <code class="samp docutils literal notranslate"><span class="pre">energy</span></code> and <code class="samp docutils literal notranslate"><span class="pre">broadening</span></code> arguments as
we’ve seen before. KPM computes the entire spectrum simultaneously, so it’s practically “free”
to compute the spatial LDOS at multiple energy values in one calculation (this is in contrast
to <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_spatial_ldos" title="pybinding.solver.Solver.calc_spatial_ldos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Solver.calc_spatial_ldos()</span></code></a> which only targets a single energy).</p>
<p>The <code class="samp docutils literal notranslate"><span class="pre">shape</span></code> argument specifies the area where the LDOS is to be calculated, i.e. the sites which
are contained within the given shape. We could just specify the same shape as the model, thus
taking all sites into consideration, but the calculation is faster for smaller areas so we’ll
narrow our focus. Our model shape is hexagonal, but we’re only interested in the LDOS at the bump
so we can look at a smaller circular area:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">spatial_ldos</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_spatial_ldos</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>  <span class="c1"># eV</span>
                                     <span class="n">shape</span><span class="o">=</span><span class="n">pb</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">radius</span><span class="o">=</span><span class="mf">2.8</span><span class="p">))</span>  <span class="c1"># only within the shape</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.7</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">gridspec</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height_ratios</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">hspace</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">energies</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]</span>  <span class="c1"># eV</span>
<span class="n">planes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="s2">&quot;xz&quot;</span><span class="p">,</span> <span class="s2">&quot;xz&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">axes</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gridspec</span><span class="p">,</span> <span class="n">energies</span><span class="p">,</span> <span class="n">planes</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;E = </span><span class="si">{}</span><span class="s2"> eV, </span><span class="si">{}</span><span class="s2">-plane&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>
    <span class="n">smap</span> <span class="o">=</span> <span class="n">spatial_ldos</span><span class="o">.</span><span class="n">structure_map</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
    <span class="n">smap</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">site_radius</span><span class="o">=</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">),</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Spatial distribution of the density of states for strained graphene" class="plot-directive" src="../_images/kpm-5.png" />
</figure>
<p>The result of the calculation is a <code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialLDOS</span></code> object which stores the
spatial LDOS for several energy values. Calling <a class="reference internal" href="../_api/pybinding.SpatialLDOS.html#pybinding.SpatialLDOS.structure_map" title="pybinding.SpatialLDOS.structure_map"><code class="xref py py-meth docutils literal notranslate"><span class="pre">SpatialLDOS.structure_map()</span></code></a> selects
a specific energy.</p>
</section>
<section id="green-s-function">
<h3><span class="section-number">10.2.4. </span>Green’s function<a class="headerlink" href="#green-s-function" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_greens" title="pybinding.chebyshev.KPM.calc_greens"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_greens()</span></code></a> can then be used to calculate Green’s function corresponding to
Hamiltonian matrix element <code class="samp docutils literal notranslate"><span class="pre">i,j</span></code> for the desired energy range and broadening:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">g_ij</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_greens</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is raw Green’s function data for the given matrix element.</p>
</section>
<section id="conductivity">
<h3><span class="section-number">10.2.5. </span>Conductivity<a class="headerlink" href="#conductivity" title="Link to this heading">¶</a></h3>
<p>The <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.calc_conductivity" title="pybinding.chebyshev.KPM.calc_conductivity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.calc_conductivity()</span></code></a> method computes the conductivity as a function of chemical
potential. The implementation uses the Kubo-Bastin formula expanded in terms of Chebyshev
polynomials, as described in <a class="reference external" href="https://doi.org/10.1103/PhysRevLett.114.116602">https://doi.org/10.1103/PhysRevLett.114.116602</a>. The following
example calculates the conductivity tensor for the quantum Hall effect in graphene with
a magnetic field:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">width</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># nanometers</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span>
    <span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span> <span class="n">pb</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span>
    <span class="n">graphene</span><span class="o">.</span><span class="n">constant_magnetic_field</span><span class="p">(</span><span class="n">magnitude</span><span class="o">=</span><span class="mi">1500</span><span class="p">)</span>  <span class="c1"># exaggerated field strength</span>
<span class="p">)</span>

<span class="c1"># The conductivity calculation is based on Green&#39;s function</span>
<span class="c1"># for which the Lorentz kernel produces better results.</span>
<span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">chebyshev</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">pb</span><span class="o">.</span><span class="n">lorentz_kernel</span><span class="p">())</span>

<span class="n">directions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sa">r</span><span class="s2">&quot;$\sigma_</span><span class="si">{xx}</span><span class="s2">$&quot;</span><span class="p">:</span> <span class="s2">&quot;xx&quot;</span><span class="p">,</span>  <span class="c1"># longitudinal conductivity</span>
    <span class="sa">r</span><span class="s2">&quot;$\sigma_</span><span class="si">{xy}</span><span class="s2">$&quot;</span><span class="p">:</span> <span class="s2">&quot;xy&quot;</span><span class="p">,</span>  <span class="c1"># off-diagonal (Hall) conductivity</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_conductivity</span><span class="p">(</span><span class="n">chemical_potential</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">300</span><span class="p">),</span>
                                  <span class="n">broadening</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                  <span class="n">volume</span><span class="o">=</span><span class="n">width</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_random</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">sigma</span><span class="o">.</span><span class="n">data</span> <span class="o">*=</span> <span class="mi">4</span>  <span class="c1"># to account for spin and valley degeneracy</span>
    <span class="n">sigma</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
<span class="n">pb</span><span class="o">.</span><span class="n">pltutils</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The calculation above takes about a minute to complete. Please take note of that if you’ve
downloaded this page as a Jupyter notebook and are executing the code on your own computer.
If you’re viewing this online, you’ll notice that the result figure is not shown. This is
because all of the figures in pybinding’s documentation are generated automatically by
readthedocs.org (RTD) from the example code (not when you load the webpage, but when a new
documentation revision is uploaded). RTD has a documentation build limit of 15 minutes so
all of the example code presented on these pages is kept short and fast, preferably under
1 second for each snippet. The long runtime of this conductivity calculation forces us to
skip it in order to conserve documentation build time.</p>
<p>You can execute this code on your own computer to see the results. The parameters here
have been tuned in order to take the minimal amount of time while still showing the desired
effect. However, that is not the most aesthetically pleasing result. To improve the quality
of the resulting figure, you can increase the size of the system, reduce the magnetic field
strength, reduce the broadening and increase the number of random vectors. That could extend
the computation time from a few minutes to several hours.</p>
</div>
</section>
</section>
<section id="damping-kernels">
<h2><span class="section-number">10.3. </span>Damping kernels<a class="headerlink" href="#damping-kernels" title="Link to this heading">¶</a></h2>
<p>KPM approximates a function as a series of Chebyshev polynomials. This series is infinite, but
numerical calculations must end at some point, thus taking into account only a finite number of
terms. This truncation results in a loss of precision and high frequency oscillations in the
computed function. In order to damp these fluctuations, the function can be convolved with various
damping kernels (the K in KPM).</p>
<p>Pybinding offers three option: <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.jackson_kernel" title="pybinding.chebyshev.jackson_kernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">jackson_kernel()</span></code></a>, <a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.lorentz_kernel" title="pybinding.chebyshev.lorentz_kernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">lorentz_kernel()</span></code></a> and
<a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.dirichlet_kernel" title="pybinding.chebyshev.dirichlet_kernel"><code class="xref py py-func docutils literal notranslate"><span class="pre">dirichlet_kernel()</span></code></a>. The Jackson kernel is enabled by default and it is the best choice
for most applications. The following example compares the three kernels:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">6.7</span><span class="p">,</span> <span class="mf">2.8</span><span class="p">))</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span> <span class="n">pb</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="mi">30</span><span class="p">),</span>
                 <span class="n">graphene</span><span class="o">.</span><span class="n">constant_magnetic_field</span><span class="p">(</span><span class="mi">400</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">121</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Damping kernels&quot;</span><span class="p">)</span>
<span class="n">kernels</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Jackson (default)&quot;</span><span class="p">:</span> <span class="n">pb</span><span class="o">.</span><span class="n">jackson_kernel</span><span class="p">(),</span>
           <span class="s2">&quot;Lorentz&quot;</span><span class="p">:</span> <span class="n">pb</span><span class="o">.</span><span class="n">lorentz_kernel</span><span class="p">()}</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">kernel</span> <span class="ow">in</span> <span class="n">kernels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">ldos</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_ldos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">ldos</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span> <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Lorentz&quot;</span> <span class="k">else</span> <span class="s2">&quot;-&quot;</span><span class="p">)</span>
<span class="n">pb</span><span class="o">.</span><span class="n">pltutils</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">122</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Undamped&quot;</span><span class="p">)</span>
<span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">pb</span><span class="o">.</span><span class="n">dirichlet_kernel</span><span class="p">())</span>
<span class="n">ldos</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">calc_ldos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="n">ldos</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;Dirichlet&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C2&quot;</span><span class="p">)</span>
<span class="n">pb</span><span class="o">.</span><span class="n">pltutils</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Comparison of KPM kernels" class="plot-directive" src="../_images/kpm-6.png" />
</figure>
<p>Computing the LDOS in graphene with a magnetic field reveals several peaks which correspond to
Landau levels. The Jackson kernel produces the best results. The <code class="samp docutils literal notranslate"><span class="pre">broadening</span></code> argument of the
calculation was set to 50 meV. With the Jackson kernel, the LDOS appears as if it was convolved
with a Gaussian of that width. On the other hand, the Lorentz kernel applies an effective
Lorentzian broadening of the same 50 meV but produces poorer results (not as sharp) simply due
to the difference in slopes of the Gaussian and Lorentzian curves.</p>
<p>Lastly, there is the Dirichlet kernel. It essentially doesn’t apply any damping and represent the
raw result of the truncated Chebyshev series. Note that the Landau levels are still present, but
there are also lots of extra oscillations (noise). The Dirichlet kernel is here mainly for
demonstration purposes and is rarely useful.</p>
<p>Out of the two proper kernels, Jackson is the default and appropriate for most applications. The
Lorentz kernels is mostly suited for Green’s function (and thus also conductivity) or in cases
where the extra smoothing of the Lorentzian may be preferable (sometimes purely aesthetically).</p>
</section>
<section id="low-level-interface">
<h2><span class="section-number">10.4. </span>Low-level interface<a class="headerlink" href="#low-level-interface" title="Link to this heading">¶</a></h2>
<p>The KPM-based calculation methods presented so far have been user-friendly and aimed at computing
a single physical property of a model. Pybinding also offers a low-level KPM interface via the
<a class="reference internal" href="../_api/pybinding.chebyshev.html#pybinding.chebyshev.KPM.moments" title="pybinding.chebyshev.KPM.moments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">KPM.moments()</span></code></a> method. It can be used to generally compute KPM expansion moments of the
form <span class="math notranslate nohighlight">\(\mu_n = &lt;\beta|op \cdot T_n(H)|\alpha&gt;\)</span>. For more information on how to use these
moments to reconstruct various functions, see <a class="reference external" href="https://doi.org/10.1103/RevModPhys.78.275">Rev. Mod. Phys. 78, 275 (2006)</a>
which explains everything in great detail.</p>
<p>We’ll just leave a quick example here. The following code calculates the LDOS in the center
of a rectangular graphene flake. This is exactly like the first example in the LDOS section above,
except that we are using the low-level interface. There is no special advantage to doing this
calculation manually (in fact, the high-level method is faster). This is here simply for
demonstration. The intended usage of the low-level interface is to create KPM-based computation
methods which are not already covered by the builtins described above.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span> <span class="n">pb</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">))</span>
<span class="n">kpm</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">kpm</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">pb</span><span class="o">.</span><span class="n">jackson_kernel</span><span class="p">())</span>

<span class="c1"># Construct a unit vector which is equal to 1 at the position</span>
<span class="c1"># where we want to calculate the local density of states</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">find_nearest</span><span class="p">(</span><span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sublattice</span><span class="o">=</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">alpha</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c1"># The broadening and the kernel determine the needed number of moments</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">scaling_factors</span>
<span class="n">broadening</span> <span class="o">=</span> <span class="mf">0.05</span>  <span class="c1"># (eV)</span>
<span class="n">num_moments</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">required_num_moments</span><span class="p">(</span><span class="n">broadening</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span>

<span class="c1"># Main calculation</span>
<span class="n">moments</span> <span class="o">=</span> <span class="n">kpm</span><span class="o">.</span><span class="n">moments</span><span class="p">(</span><span class="n">num_moments</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>  <span class="c1"># optionally also takes beta and an operator</span>

<span class="c1"># Reconstruct the LDOS function</span>
<span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">8.42</span><span class="p">,</span> <span class="mf">8.42</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">scaled_energy</span> <span class="o">=</span> <span class="p">(</span><span class="n">energy</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">a</span>
<span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_moments</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">scaled_energy</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">chebyshev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ns</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">scaled_energy</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]))</span>
<span class="n">ldos</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">moments</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">chebyshev</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">ldos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;E (eV)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;LDOS&quot;</span><span class="p">)</span>
<span class="n">pb</span><span class="o">.</span><span class="n">pltutils</span><span class="o">.</span><span class="n">despine</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/kpm-7.png" class="plot-directive" src="../_images/kpm-7.png" />
</figure>
</section>
<section id="further-reading">
<h2><span class="section-number">10.5. </span>Further reading<a class="headerlink" href="#further-reading" title="Link to this heading">¶</a></h2>
<p>For an additional examples see the <a class="reference internal" href="fields.html#magnetic-field-modifier"><span class="std std-ref">Magnetic field</span></a> subsection of <a class="reference internal" href="fields.html"><span class="doc">Fields and effects</span></a> as
well as the <a class="reference internal" href="strain.html#strain-modifier"><span class="std std-ref">Strain modifier</span></a> subsection of <a class="reference internal" href="strain.html"><span class="doc">Defects and strain</span></a>.
The reference page for the <a class="reference internal" href="../_api/pybinding.chebyshev.html#module-pybinding.chebyshev" title="pybinding.chebyshev"><code class="xref py py-mod docutils literal notranslate"><span class="pre">chebyshev</span></code></a> submodule contains more information.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="solvers.html" class="btn btn-neutral float-left" title="9. Eigenvalue solvers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="scattering.html" class="btn btn-neutral float-right" title="11. Scattering model" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2024, Bert Jorissen, Dean Moldovan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>