

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="Computing the eigenvalues and eigenvectors of a tight-binding Hamiltonian matrix" name="description" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9. Eigenvalue solvers &mdash; pybinding</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />

  
    <link rel="stylesheet" href="../_static/extra.css" type="text/css" />
      <script src="../_static/documentation_options.js?v=e2a723ec"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10. Kernel polynomial method" href="kpm.html" />
    <link rel="prev" title="8. Generators" href="generators.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            pybinding
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">About</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks/index.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutorial</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="import.html">1. Imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="lattice.html">2. Lattice</a></li>
<li class="toctree-l2"><a class="reference internal" href="bands.html">3. Band structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="finite.html">4. Finite size</a></li>
<li class="toctree-l2"><a class="reference internal" href="shape_symmetry.html">5. Shape and symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="fields.html">6. Fields and effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="strain.html">7. Defects and strain</a></li>
<li class="toctree-l2"><a class="reference internal" href="generators.html">8. Generators</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">9. Eigenvalue solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lapack">9.1. LAPACK</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arpack">9.2. ARPACK</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solver-interface">9.3. Solver interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#further-reading">9.4. Further reading</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="kpm.html">10. Kernel polynomial method</a></li>
<li class="toctree-l2"><a class="reference internal" href="scattering.html">11. Scattering model</a></li>
<li class="toctree-l2"><a class="reference internal" href="wavefunction.html">12. Wavefunction calculations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../advanced/index.html">Additional Topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plotting/index.html">Plotting Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Random Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference docs</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../materials/index.html">Material Repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../experimental/index.html">Experimental</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pybinding</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Tutorial</a></li>
      <li class="breadcrumb-item active"><span class="section-number">9. </span>Eigenvalue solvers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tutorial/solvers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="eigenvalue-solvers">
<h1><span class="section-number">9. </span>Eigenvalue solvers<a class="headerlink" href="#eigenvalue-solvers" title="Link to this heading">¶</a></h1>
<p>Solvers were first introduced in the <a class="reference internal" href="bands.html"><span class="doc">Band structure</span></a> section and then used throughout the tutorial to
present the results of the various models we constructed. This section will take a more detailed
look at the concrete <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.lapack" title="pybinding.solver.lapack"><code class="xref py py-func docutils literal notranslate"><span class="pre">lapack()</span></code></a> and <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.arpack" title="pybinding.solver.arpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">arpack()</span></code></a> eigenvalue solvers and their common
<a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver" title="pybinding.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> interface.</p>
<p><a class="reference download internal" download="" href="../_downloads/af6de3f205b2a7e237a4bf5fb81abbc9/solvers.ipynb"><code class="xref nbexport download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">this</span> <span class="pre">page</span> <span class="pre">as</span> <span class="pre">a</span> <span class="pre">Jupyter</span> <span class="pre">notebook</span></code></a></p>
<section id="lapack">
<h2><span class="section-number">9.1. </span>LAPACK<a class="headerlink" href="#lapack" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver" title="pybinding.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> class establishes the interface of a solver within pybinding, but it does not
contain a concrete diagonalization routine. For this reason we never instantiate the plain solver,
only its implementations such as <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.lapack" title="pybinding.solver.lapack"><code class="xref py py-func docutils literal notranslate"><span class="pre">solver.lapack()</span></code></a>.</p>
<p>The LAPACK implementation works on dense matrices which makes it well suited only for small
systems. However, a great advantage of this solver is that it always solves for all eigenvalues
and eigenvectors of a Hamiltonian matrix. This makes it perfect for calculating the entire band
structure of the bulk or nanoribbons, as has been shown several times in this tutorial.</p>
<p>Internally, this solver uses the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigh.html#scipy.linalg.eigh" title="(in SciPy v1.15.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.linalg.eigh()</span></code></a> function for dense Hermitian matrices.
See the <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.lapack" title="pybinding.solver.lapack"><code class="xref py py-func docutils literal notranslate"><span class="pre">solver.lapack()</span></code></a> API reference for more details.</p>
</section>
<section id="arpack">
<h2><span class="section-number">9.2. </span>ARPACK<a class="headerlink" href="#arpack" title="Link to this heading">¶</a></h2>
<p>The <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.arpack" title="pybinding.solver.arpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">solver.arpack()</span></code></a> implementation works on sparse matrices which makes it suitable for
large systems. However, only a small subset of the total eigenvalues and eigenvectors can be
calculated. This tutorial already contains a few examples where the ARPACK solver was used, and
one more is presented below.</p>
<p>Internally, the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="(in SciPy v1.15.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigsh()</span></code></a> function is used to solve large sparse Hermitian
matrices. The first argument to <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.arpack" title="pybinding.solver.arpack"><code class="xref py py-func docutils literal notranslate"><span class="pre">solver.arpack()</span></code></a> must be the pybinding <a class="reference internal" href="../_api/pybinding.Model.html#pybinding.Model" title="pybinding.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a>, but
the following arguments are the same as <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="(in SciPy v1.15.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigsh()</span></code></a>, so the solver routine
can be tweaked as desired. Rather than reproduce the full list of options here, we refer you to
the scipy <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="(in SciPy v1.15.2)"><code class="xref py py-func docutils literal notranslate"><span class="pre">eigsh()</span></code></a> reference documentation. Here, we will focus on the
specific features of solvers within pybinding.</p>
</section>
<section id="solver-interface">
<h2><span class="section-number">9.3. </span>Solver interface<a class="headerlink" href="#solver-interface" title="Link to this heading">¶</a></h2>
<p>No matter which concrete solver is used, they all share a common <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver" title="pybinding.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> interface.
The two primary properties are <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.eigenvalues" title="pybinding.solver.Solver.eigenvalues"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eigenvalues</span></code></a> and <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.eigenvectors" title="pybinding.solver.Solver.eigenvectors"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eigenvectors</span></code></a>.
These are the raw results of the exact diagonalization of the Hamiltonian matrix.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pybinding.repository</span><span class="w"> </span><span class="kn">import</span> <span class="n">graphene</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">hamiltonian</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
<span class="go">[[ 0.0 -2.8]</span>
<span class="go"> [-2.8  0.0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">lapack</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">eigenvalues</span>
<span class="go">[-2.8 2.8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">solver</span><span class="o">.</span><span class="n">eigenvectors</span>
<span class="go">[[-0.707 -0.707]</span>
<span class="go"> [-0.707  0.707]]</span>
</pre></div>
</div>
<p>The properties contain just the raw data. However, <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver" title="pybinding.solver.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> also offers a few convenient
calculation methods. We’ll demonstrate these on a simple rectangular graphene system.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pybinding.repository</span><span class="w"> </span><span class="kn">import</span> <span class="n">graphene</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span>
    <span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span>
    <span class="n">pb</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="../_images/solvers-1.png" class="plot-directive" src="../_images/solvers-1.png" />
</figure>
<p>First, we’ll take a look at the <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_eigenvalues" title="pybinding.solver.Solver.calc_eigenvalues"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_eigenvalues()</span></code></a> method. While its job is
essentially the same as the <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.eigenvalues" title="pybinding.solver.Solver.eigenvalues"><code class="xref py py-attr docutils literal notranslate"><span class="pre">eigenvalues</span></code></a> property, there is one key difference:
the property returns a raw array, while the method returns an <a class="reference internal" href="../_api/pybinding.Eigenvalues.html#pybinding.Eigenvalues" title="pybinding.Eigenvalues"><code class="xref py py-class docutils literal notranslate"><span class="pre">Eigenvalues</span></code></a> result object.
These objects have convenient functions built in and they know how to plot their data:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">arpack</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>  <span class="c1"># for the 20 lowest energy eigenvalues</span>
<span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">calc_eigenvalues</span><span class="p">()</span>
<span class="n">eigenvalues</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Energy states of a graphene quantum dot" class="plot-directive" src="../_images/solvers-2.png" />
</figure>
<p>The basic plot just shows the state number and energy of each eigenstate, but we can also do
something more interesting. If we pass a position argument to <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_eigenvalues" title="pybinding.solver.Solver.calc_eigenvalues"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_eigenvalues()</span></code></a>
it will calculate the probability density <span class="math notranslate nohighlight">\(|\Psi(\vec{r})|^2\)</span> at that position for each
eigenstate and we can view the result using <a class="reference internal" href="../_api/pybinding.Eigenvalues.html#pybinding.Eigenvalues.plot_heatmap" title="pybinding.Eigenvalues.plot_heatmap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Eigenvalues.plot_heatmap()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">calc_eigenvalues</span><span class="p">(</span><span class="n">map_probability_at</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">])</span>  <span class="c1"># position in [nm]</span>
<span class="n">eigenvalues</span><span class="o">.</span><span class="n">plot_heatmap</span><span class="p">(</span><span class="n">show_indices</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">pb</span><span class="o">.</span><span class="n">pltutils</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Energy states of a graphene quantum dot with probability heatmap" class="plot-directive" src="../_images/solvers-3.png" />
</figure>
<p>In this case we are interested in the probability density at <code class="samp docutils literal notranslate"><span class="pre">[x,</span> <span class="pre">y]</span> <span class="pre">=</span> <span class="pre">[0.1,</span> <span class="pre">0.6]</span></code>, i.e. a lattice
site at the top zigzag edge of our system. Note that the given position does not need to be
precise: the probability will be computed for the site closest to the given coordinates. From the
figure we can see that the probability at the edge is highest for the two zero-energy states:
numbers 9 and 10. We can take a look at the spatial map of state 9 using the
<a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_probability" title="pybinding.solver.Solver.calc_probability"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_probability()</span></code></a> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">probability_map</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">calc_probability</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">probability_map</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Spatial map of the probability density of a graphene quantum dot" class="plot-directive" src="../_images/solvers-4.png" />
</figure>
<p>The result object in this case is a <a class="reference internal" href="../_api/pybinding.StructureMap.html#pybinding.StructureMap" title="pybinding.StructureMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">StructureMap</span></code></a> with the probability density
<span class="math notranslate nohighlight">\(|\Psi(\vec{r})|^2\)</span> as its data attribute. As expected, the most prominent states are at
the zigzag edges of the system.</p>
<p>An alternative way to get a spatial map of the system is via the local density of states (LDOS).
The <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_spatial_ldos" title="pybinding.solver.Solver.calc_spatial_ldos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_spatial_ldos()</span></code></a> method makes this easy. The LDOS map is requested for a
specific energy value instead of a state number and it considers multiple states within a Gaussian
function with the specified broadening:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ldos_map</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">calc_spatial_ldos</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>  <span class="c1"># [eV]</span>
<span class="n">ldos_map</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Spatial LDOS of a graphene quantum dot" class="plot-directive" src="../_images/solvers-5.png" />
</figure>
<p>The total density of states can be calculated with <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_dos" title="pybinding.solver.Solver.calc_dos"><code class="xref py py-meth docutils literal notranslate"><span class="pre">calc_dos()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dos</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">calc_dos</span><span class="p">(</span><span class="n">energies</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>  <span class="c1"># [eV]</span>
<span class="n">dos</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Total density of states (DOS) of a graphene quantum dot" class="plot-directive" src="../_images/solvers-6.png" />
</figure>
<p>Our example system is quite small so the DOS does not resemble bulk graphene. The zero-energy peak
stands out as the signature of the zigzag edge states.</p>
<p id="manual-band-calculation">For periodic systems, the wave vector can be controlled using <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.set_wave_vector" title="pybinding.solver.Solver.set_wave_vector"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Solver.set_wave_vector()</span></code></a>.
This allows us to compute the eigenvalues at various points in k-space. For example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">pi</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span>
    <span class="n">graphene</span><span class="o">.</span><span class="n">monolayer</span><span class="p">(),</span>
    <span class="n">pb</span><span class="o">.</span><span class="n">translational_symmetry</span><span class="p">()</span>
<span class="p">)</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">lapack</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>

<span class="n">kx_lim</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">graphene</span><span class="o">.</span><span class="n">a</span>
<span class="n">kx_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">kx_lim</span><span class="p">,</span> <span class="n">kx_lim</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">ky_outer</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ky_inner</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">graphene</span><span class="o">.</span><span class="n">a_cc</span><span class="p">)</span>

<span class="n">outer_bands</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">kx</span> <span class="ow">in</span> <span class="n">kx_path</span><span class="p">:</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_wave_vector</span><span class="p">([</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky_outer</span><span class="p">])</span>
    <span class="n">outer_bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)</span>

<span class="n">inner_bands</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">kx</span> <span class="ow">in</span> <span class="n">kx_path</span><span class="p">:</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_wave_vector</span><span class="p">([</span><span class="n">kx</span><span class="p">,</span> <span class="n">ky_inner</span><span class="p">])</span>
    <span class="n">inner_bands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">eigenvalues</span><span class="p">)</span>

<span class="k">for</span> <span class="n">bands</span> <span class="ow">in</span> <span class="p">[</span><span class="n">outer_bands</span><span class="p">,</span> <span class="n">inner_bands</span><span class="p">]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">results</span><span class="o">.</span><span class="n">Bands</span><span class="p">(</span><span class="n">kx_path</span><span class="p">,</span> <span class="n">bands</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-default">
<img alt="Graphene band structure" class="plot-directive" src="../_images/solvers-7.png" />
</figure>
<p>This example shows the basic principle of iterating over a path in k-space in order to calculate
the band structure. However, this is made much easier with the <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_bands" title="pybinding.solver.Solver.calc_bands"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Solver.calc_bands()</span></code></a> method.
This was already covered in the <a class="reference internal" href="bands.html"><span class="doc">Band structure</span></a> section and will not be repeated here. But keep in
mind that this calculation does not need to be done manually, <a class="reference internal" href="../_api/pybinding.solver.html#pybinding.solver.Solver.calc_bands" title="pybinding.solver.Solver.calc_bands"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Solver.calc_bands()</span></code></a> is the
preferred way.</p>
</section>
<section id="further-reading">
<h2><span class="section-number">9.4. </span>Further reading<a class="headerlink" href="#further-reading" title="Link to this heading">¶</a></h2>
<p>Take a look at the <a class="reference internal" href="../_api/pybinding.solver.html#module-pybinding.solver" title="pybinding.solver"><code class="xref py py-mod docutils literal notranslate"><span class="pre">solver</span></code></a> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">results</span></code> reference pages for more detailed
information. More solver examples are available throughout this tutorial.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="generators.html" class="btn btn-neutral float-left" title="8. Generators" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="kpm.html" class="btn btn-neutral float-right" title="10. Kernel polynomial method" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2024, Bert Jorissen, Dean Moldovan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>